#pragma version 8

// Dutch Payment Mechanism Smart Contract for NFT Minting
// This contract manages a queue of mint requests and triggers batch minting when threshold is met

// Global State Schema:
// - threshold (uint64): Minimum number of assets required to trigger minting
// - queue_count (uint64): Current number of assets in queue
// - base_cost (uint64): Base minting cost per asset (in microAlgos)
// - effective_cost (uint64): Effective cost per asset when threshold is met (in microAlgos)
// - platform_address (bytes): Platform wallet address for receiving payments
// - escrow_address (bytes): Escrow account address for holding locked funds
// - time_window (uint64): Time window in seconds for threshold to be met
// - queue_start_time (uint64): Timestamp when current queue started
// - total_escrowed (uint64): Total amount escrowed in microAlgos

// Local State Schema (per user):
// - request_count (uint64): Number of assets requested by this user
// - escrowed_amount (uint64): Amount escrowed by this user (in microAlgos)
// - request_ids (bytes): Serialized list of request IDs

// Application Arguments:
// 0: Method selector
//    - "init" (0x696e6974): Initialize contract
//    - "join_queue" (0x6a6f696e): Join minting queue
//    - "trigger_mint" (0x74726967): Trigger batch minting (if threshold met)
//    - "refund" (0x72656675): Request refund
//    - "get_status" (0x73746174): Get queue status

// Check if this is application creation
// During creation, ApplicationID is 0 AND OnCompletion is NoOpOC (0)
// This MUST be checked first before any other logic
txn ApplicationID
int 0
==
txn OnCompletion
int 0
==
&&
bnz creation

// On Update/Delete/ClearState - Only creator can do this
txn OnCompletion
int UpdateApplication
==
txn OnCompletion
int DeleteApplication
==
||
txn OnCompletion
int ClearState
==
||
bnz handle_update_delete

// On OptIn - Allow opt-in (no ApplicationArgs needed)
txn OnCompletion
int OptIn
==
bnz handle_optin

// Main logic (ApplicationID != 0)
txn ApplicationID
int 0
!=
bnz main_logic

// Fallthrough - should not reach here
err

// Creation logic
creation:
  // Validate that all required arguments are provided
  // Args: [0="init", 1=threshold, 2=base_cost, 3=effective_cost, 4=platform_address, 5=escrow_address, 6=time_window]
  txn NumAppArgs
  int 7
  >=
  bnz creation_args_valid
  byte "creation_args_error"
  log
  err
  
creation_args_valid:
  // Validate platform_address is 32 bytes
  txn ApplicationArgs 4
  len
  int 32
  ==
  bnz validate_escrow_address
  byte "platform_address_error"
  log
  err
  
validate_escrow_address:
  // Validate escrow_address is 32 bytes
  txn ApplicationArgs 5
  len
  int 32
  ==
  bnz store_creation_params
  byte "escrow_address_error"
  log
  err
  
store_creation_params:
  // Store initial parameters
  byte "threshold"
  txn ApplicationArgs 1
  btoi
  app_global_put
  
  byte "base_cost"
  txn ApplicationArgs 2
  btoi
  app_global_put
  
  byte "effective_cost"
  txn ApplicationArgs 3
  btoi
  app_global_put
  
  byte "platform_address"
  txn ApplicationArgs 4
  app_global_put
  
  byte "escrow_address"
  txn ApplicationArgs 5
  app_global_put
  
  byte "time_window"
  txn ApplicationArgs 6
  btoi
  app_global_put
  
  byte "queue_count"
  int 0
  app_global_put
  
  byte "total_escrowed"
  int 0
  app_global_put
  
  byte "queue_start_time"
  int 0
  app_global_put
  
  int 1
  return

// Update/Delete - Only creator
handle_update_delete:
  txn Sender
  global CreatorAddress
  ==
  return

// OptIn - Allow any account to opt in (initialize local state to 0)
handle_optin:
  // Initialize local state for the opting-in account
  // app_local_put expects [account, key, value]
  txn Sender
  byte "request_count"
  int 0
  app_local_put
  
  txn Sender
  byte "escrowed_amount"
  int 0
  app_local_put
  
  int 1
  return

// Main application logic
main_logic:
  // CRITICAL: Check if ApplicationArgs exist before accessing them
  // This prevents "invalid ApplicationArgs index 0" error
  txn NumAppArgs
  int 1
  <
  bnz no_app_args
  
  // Log method selector for debugging (helps identify encoding issues)
  txn ApplicationArgs 0
  dup
  log  // Log the raw method selector bytes
  
  // Get method selector and compare
  txn ApplicationArgs 0
  byte "init"
  ==
  bnz init_method
  
  txn ApplicationArgs 0
  byte "join_queue"
  ==
  bnz join_queue_method
  
  txn ApplicationArgs 0
  byte "trigger_mint"
  ==
  bnz trigger_mint_method
  
  txn ApplicationArgs 0
  byte "refund"
  ==
  bnz refund_method
  
  txn ApplicationArgs 0
  byte "get_status"
  ==
  bnz get_status_method
  
  // Unknown method - log error and fail
  byte "unknown_method"
  log
  err
  
no_app_args:
  // No application arguments provided - this is invalid for main logic
  byte "no_app_args"
  log
  err

// Initialize queue (if not already initialized)
init_method:
  byte "queue_start_time"
  app_global_get
  int 0
  ==
  bnz set_start_time
  int 1
  return
  
set_start_time:
  byte "queue_start_time"
  global LatestTimestamp
  app_global_put
  int 1
  return

// Join queue method
join_queue_method:
  // Args: [method, request_count]
  // Payment transaction must be included in group
  
  // Verify group size is at least 2 (app call + payment)
  global GroupSize
  int 2
  >=
  bnz check_payment_txn
  byte "group_size_error"
  log
  err
  
check_payment_txn:
  // Payment can be at index 1 (if no opt-in) or index 2 (if opt-in is included)
  // Check index 1 first
  gtxn 1 TypeEnum
  int 1  // pay
  ==
  bnz payment_at_index_1
  
  // If not at index 1, check index 2 (for groups with opt-in)
  global GroupSize
  int 3
  >=
  bnz check_index_2
  byte "payment_txn_error"
  log
  err
  
check_index_2:
  gtxn 2 TypeEnum
  int 1  // pay
  ==
  bnz payment_at_index_2
  byte "payment_txn_error"
  log
  err
  
payment_at_index_1:
  // Payment is at index 1 (group size = 2: app call + payment)
  b payment_valid
  
payment_at_index_2:
  // Payment is at index 2 (group size = 3: opt-in + app call + payment)
  b payment_valid
  
payment_valid:
  
  // Get request count
  txn ApplicationArgs 1
  btoi
  store 0  // request_count
  
  // Check if contract state is initialized
  // We need ALL of: escrow_address (byteslice, len == 32), threshold (int, > 0), AND effective_cost (int, > 0)
  // Default to uninitialized path - only go to initialized if ALL checks pass AND payment matches
  
  // Check escrow_address (must be byteslice with length == 32)
  byte "escrow_address"
  app_global_get
  dup
  len
  int 32
  ==
  bnz check_threshold  // Escrow address is 32 bytes - check threshold
  pop  // Remove escrow_address from stack
  b state_not_initialized  // Escrow address is not 32 bytes - state not initialized
  
check_threshold:
  pop  // Remove escrow_address from stack (we'll re-read it in state_initialized)
  
  // Check threshold (must be integer > 0)
  byte "threshold"
  app_global_get
  dup
  int 0
  >
  bnz check_effective_cost  // Threshold > 0 - check effective_cost
  pop  // Remove threshold from stack
  b state_not_initialized  // Threshold is 0 or negative - state not initialized
  
check_effective_cost:
  pop  // Remove threshold from stack
  
  // Check effective_cost (must be integer > 0)
  byte "effective_cost"
  app_global_get
  dup
  int 0
  >
  bnz verify_escrow_match  // Effective cost > 0 - verify payment matches escrow
  pop  // Remove effective_cost from stack
  b state_not_initialized  // Effective cost is 0 or negative - state not initialized
  
verify_escrow_match:
  pop  // Remove effective_cost from stack
  
  // Verify payment receiver matches escrow address BEFORE going to state_initialized
  // This prevents errors if addresses don't match
  // Payment can be at index 1 or 2 depending on group size
  global GroupSize
  int 3
  >=
  bnz check_escrow_index_2
  
  // Group size is 2, payment is at index 1
  gtxn 1 Receiver
  byte "escrow_address"
  app_global_get
  ==
  bnz state_initialized  // Payment receiver matches escrow - state is fully initialized
  b state_not_initialized  // Payment receiver doesn't match - fall back to uninitialized path
  
check_escrow_index_2:
  // Group size is 3, payment is at index 2
  gtxn 2 Receiver
  byte "escrow_address"
  app_global_get
  ==
  bnz state_initialized  // Payment receiver matches escrow - state is fully initialized
  b state_not_initialized  // Payment receiver doesn't match - fall back to uninitialized path
  
state_not_initialized:
  // State not initialized - skip validation (backend handles validation)
  // app_global_get on non-existent key returns 0, so we can safely add
  byte "queue_count"
  app_global_get
  load 0
  +
  app_global_put
  
  // Update total escrowed (use payment amount from transaction)
  // Payment can be at index 1 or 2 depending on group size
  global GroupSize
  int 3
  >=
  bnz get_payment_amount_index_2
  
  // Group size is 2, payment is at index 1
  gtxn 1 Amount
  b add_to_total_escrowed
  
get_payment_amount_index_2:
  // Group size is 3, payment is at index 2
  gtxn 2 Amount
  
add_to_total_escrowed:
  byte "total_escrowed"
  app_global_get
  +
  app_global_put
  
  // Set queue start time if not set
  byte "queue_start_time"
  app_global_get
  int 0
  ==
  bnz set_start_time_uninit
  
  // Update user local state
  // Check if account has opted in (app_opted_in expects [address, app_id] on stack)
  txn Sender
  global CurrentApplicationID
  app_opted_in
  bnz update_existing_local_state_1
  
  // Account hasn't opted in - reject (opt-in must be done via separate transaction)
  byte "optin_required"
  log
  err
  
update_existing_local_state_1:
  // Account has opted in - get existing values and add to them
  // app_local_get expects [account, key] on stack
  txn Sender
  byte "request_count"
  app_local_get
  load 0
  +
  store 4  // new_request_count
  txn Sender
  byte "request_count"
  load 4
  app_local_put
  
  txn Sender
  byte "escrowed_amount"
  app_local_get
  // Payment can be at index 1 or 2 depending on group size
  global GroupSize
  int 3
  >=
  bnz get_escrow_amount_index_2_1
  
  // Group size is 2, payment is at index 1
  gtxn 1 Amount
  b add_to_escrowed_1
  
get_escrow_amount_index_2_1:
  // Group size is 3, payment is at index 2
  gtxn 2 Amount
  
add_to_escrowed_1:
  +
  store 5  // new_escrowed_amount
  txn Sender
  byte "escrowed_amount"
  load 5
  app_local_put
  
skip_update_local_state_1:
  
  int 1
  return
  
set_start_time_uninit:
  byte "queue_start_time"
  global LatestTimestamp
  app_global_put
  
  // Update user local state
  // Check if account has opted in (app_opted_in expects [address, app_id] on stack)
  txn Sender
  global CurrentApplicationID
  app_opted_in
  bnz update_existing_local_state_2
  
  // Account hasn't opted in - reject (opt-in must be done via separate transaction)
  byte "optin_required"
  log
  err
  
update_existing_local_state_2:
  // Account has opted in - get existing values and add to them
  // app_local_get expects [account, key] on stack
  txn Sender
  byte "request_count"
  app_local_get
  load 0
  +
  store 4  // new_request_count
  txn Sender
  byte "request_count"
  load 4
  app_local_put
  
  txn Sender
  byte "escrowed_amount"
  app_local_get
  // Payment can be at index 1 or 2 depending on group size
  global GroupSize
  int 3
  >=
  bnz get_escrow_amount_index_2_2
  
  // Group size is 2, payment is at index 1
  gtxn 1 Amount
  b add_to_escrowed_2
  
get_escrow_amount_index_2_2:
  // Group size is 3, payment is at index 2
  gtxn 2 Amount
  
add_to_escrowed_2:
  +
  store 5  // new_escrowed_amount
  txn Sender
  byte "escrowed_amount"
  load 5
  app_local_put
  
skip_update_local_state_2:
  
  int 1
  return
  
state_initialized:
  // State is initialized - verify payment is to escrow address
  // If verification fails, fall back to uninitialized path (backend handles validation)
  // Payment can be at index 1 or 2 depending on group size
  global GroupSize
  int 3
  >=
  bnz check_escrow_index_2_state
  
  // Group size is 2, payment is at index 1
  gtxn 1 Receiver
  byte "escrow_address"
  app_global_get
  ==
  bnz verify_payment_amount  // Escrow address matches - continue with validation
  b state_not_initialized  // Escrow address doesn't match - fall back to uninitialized path
  
check_escrow_index_2_state:
  // Group size is 3, payment is at index 2
  gtxn 2 Receiver
  byte "escrow_address"
  app_global_get
  ==
  bnz verify_payment_amount  // Escrow address matches - continue with validation
  b state_not_initialized  // Escrow address doesn't match - fall back to uninitialized path
  
verify_payment_amount:
  // Calculate expected payment (effective_cost * request_count)
  // We already verified effective_cost > 0 in the state check
  byte "effective_cost"
  app_global_get
  load 0
  *
  store 1  // expected_payment
  
  // Verify payment amount matches (if it doesn't, fall back to uninitialized)
  // Payment can be at index 1 or 2 depending on group size
  global GroupSize
  int 3
  >=
  bnz check_payment_amount_index_2
  
  // Group size is 2, payment is at index 1
  gtxn 1 Amount
  load 1
  >=
  bnz update_state  // Payment amount is sufficient - continue
  b state_not_initialized  // Payment amount doesn't match - fall back to uninitialized path
  
check_payment_amount_index_2:
  // Group size is 3, payment is at index 2
  gtxn 2 Amount
  load 1
  >=
  bnz update_state  // Payment amount is sufficient - continue
  b state_not_initialized  // Payment amount doesn't match - fall back to uninitialized path
  
update_state:
  
  // Update global queue count
  byte "queue_count"
  app_global_get
  load 0
  +
  store 2  // new_queue_count
  byte "queue_count"
  load 2
  app_global_put
  
  // Update total escrowed
  // Payment can be at index 1 or 2 depending on group size
  global GroupSize
  int 3
  >=
  bnz get_payment_amount_index_2_state
  
  // Group size is 2, payment is at index 1
  gtxn 1 Amount
  b add_to_total_escrowed_state
  
get_payment_amount_index_2_state:
  // Group size is 3, payment is at index 2
  gtxn 2 Amount
  
add_to_total_escrowed_state:
  byte "total_escrowed"
  app_global_get
  +
  store 3  // new_total_escrowed
  byte "total_escrowed"
  load 3
  app_global_put
  
  // Update user local state
  // Check if account has opted in (app_opted_in expects [address, app_id] on stack)
  txn Sender
  global CurrentApplicationID
  app_opted_in
  bnz update_existing_local_state_3
  
  // Account hasn't opted in - reject (opt-in must be done via separate transaction)
  byte "optin_required"
  log
  err
  
update_existing_local_state_3:
  // Account has opted in - get existing values and add to them
  // app_local_get expects [account, key] on stack
  txn Sender
  byte "request_count"
  app_local_get
  load 0
  +
  store 4  // new_request_count
  txn Sender
  byte "request_count"
  load 4
  app_local_put
  
  txn Sender
  byte "escrowed_amount"
  app_local_get
  // Payment can be at index 1 or 2 depending on group size
  global GroupSize
  int 3
  >=
  bnz get_escrow_amount_index_2_3
  
  // Group size is 2, payment is at index 1
  gtxn 1 Amount
  b add_to_escrowed_3
  
get_escrow_amount_index_2_3:
  // Group size is 3, payment is at index 2
  gtxn 2 Amount
  
add_to_escrowed_3:
  +
  store 5  // new_escrowed_amount
  txn Sender
  byte "escrowed_amount"
  load 5
  app_local_put
  
skip_update_local_state_3:
  
  // If queue_start_time is 0, set it now
  byte "queue_start_time"
  app_global_get
  int 0
  ==
  bnz set_queue_start
  int 1
  return
  
set_queue_start:
  byte "queue_start_time"
  global LatestTimestamp
  app_global_put
  int 1
  return

// Trigger mint method (only if threshold met)
trigger_mint_method:
  // Check if threshold is met
  byte "queue_count"
  app_global_get
  byte "threshold"
  app_global_get
  >=
  assert
  
  // Verify payment transaction from escrow to platform (if in group)
  global GroupSize
  int 2
  >=
  bnz check_payment
  
  // No payment transaction, just trigger (platform will handle minting off-chain)
  int 1
  return
  
check_payment:
  // Payment can be at index 1 or 2 depending on group size (if opt-in is included)
  global GroupSize
  int 3
  >=
  bnz check_trigger_payment_index_2
  
  // Group size is 2, payment is at index 1
  gtxn 1 TypeEnum
  int 1  // pay
  ==
  assert
  
  gtxn 1 Sender
  byte "escrow_address"
  app_global_get
  ==
  assert
  
  gtxn 1 Receiver
  byte "platform_address"
  app_global_get
  ==
  assert
  b reset_queue
  
check_trigger_payment_index_2:
  // Group size is 3, payment is at index 2
  gtxn 2 TypeEnum
  int 1  // pay
  ==
  assert
  
  gtxn 2 Sender
  byte "escrow_address"
  app_global_get
  ==
  assert
  
  gtxn 2 Receiver
  byte "platform_address"
  app_global_get
  ==
  assert
  
reset_queue:
  
  // Reset queue
  byte "queue_count"
  int 0
  app_global_put
  
  byte "total_escrowed"
  int 0
  app_global_put
  
  byte "queue_start_time"
  int 0
  app_global_put
  
  int 1
  return

// Refund method
refund_method:
  // Check if time window expired and threshold not met
  byte "queue_start_time"
  app_global_get
  store 0  // start_time
  
  load 0
  int 0
  ==
  bnz no_queue
  
  byte "time_window"
  app_global_get
  load 0
  +
  store 1  // expiry_time
  
  global LatestTimestamp
  load 1
  <
  bnz time_not_expired
  
  // Time expired, check threshold
  byte "queue_count"
  app_global_get
  byte "threshold"
  app_global_get
  <
  assert
  
  // Refund user's escrowed amount
  // app_local_get expects [account, key] on stack
  txn Sender
  byte "escrowed_amount"
  app_local_get
  store 2  // user_escrowed
  
  load 2
  int 0
  >
  assert
  
  // Verify refund transaction in group
  // Payment can be at index 1 or 2 depending on group size (if opt-in is included)
  global GroupSize
  int 3
  >=
  bnz check_refund_payment_index_2
  
  // Group size is 2, payment is at index 1
  gtxn 1 TypeEnum
  int 1  // pay
  ==
  assert
  
  gtxn 1 Sender
  byte "escrow_address"
  app_global_get
  ==
  assert
  
  gtxn 1 Receiver
  txn Sender
  ==
  assert
  
  gtxn 1 Amount
  load 2
  >=
  assert
  b update_refund_state
  
check_refund_payment_index_2:
  // Group size is 3, payment is at index 2
  gtxn 2 TypeEnum
  int 1  // pay
  ==
  assert
  
  gtxn 2 Sender
  byte "escrow_address"
  app_global_get
  ==
  assert
  
  gtxn 2 Receiver
  txn Sender
  ==
  assert
  
  gtxn 2 Amount
  load 2
  >=
  assert
  
update_refund_state:
  
  // Update global state
  byte "queue_count"
  app_global_get
  // app_local_get expects [account, key] on stack
  txn Sender
  byte "request_count"
  app_local_get
  -
  store 3  // new_queue_count
  byte "queue_count"
  load 3
  app_global_put
  
  byte "total_escrowed"
  app_global_get
  load 2
  -
  store 4  // new_total_escrowed
  byte "total_escrowed"
  load 4
  app_global_put
  
  // Clear user local state
  // app_local_put expects [account, key, value] on stack
  txn Sender
  byte "request_count"
  int 0
  app_local_put
  
  txn Sender
  byte "escrowed_amount"
  int 0
  app_local_put
  
  int 1
  return
  
time_not_expired:
  err
  
no_queue:
  err

// Get status method (read-only, returns via logs)
get_status_method:
  // Return status information via logs
  byte "queue_count"
  app_global_get
  itob
  log
  
  byte "threshold"
  app_global_get
  itob
  log
  
  byte "total_escrowed"
  app_global_get
  itob
  log
  
  byte "queue_start_time"
  app_global_get
  itob
  log
  
  int 1
  return
